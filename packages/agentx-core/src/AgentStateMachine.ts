/**
 * AgentStateMachine
 *
 * State machine that automatically generates State Layer events from Stream Layer events.
 *
 * Architecture:
 * ```
 * Stream Events (from Driver)
 *     ↓ Subscribe
 * AgentStateMachine (this class)
 *     ↓ Emit
 * State Events (to EventBus)
 * ```
 *
 * Responsibilities:
 * 1. Subscribe to Stream Layer events from EventBus
 * 2. Track agent state transitions
 * 3. Automatically emit State Layer events
 * 4. Maintain state machine logic
 *
 * State Transitions:
 * ```
 * AgentInitializing
 *     ↓ (MessageStartEvent)
 * ConversationStart
 *     ↓ (ThinkingContentBlockStart)
 * ConversationThinking
 *     ↓ (TextContentBlockStart)
 * ConversationResponding
 *     ↓ (MessageStopEvent)
 * ConversationEnd
 * ```
 *
 * Example:
 * ```typescript
 * const stateMachine = new AgentStateMachine(agentId, eventBus);
 *
 * // Stream event arrives
 * eventBus.emit(messageStartEvent);
 *
 * // StateMachine automatically emits
 * // → ConversationStartStateEvent
 * ```
 */

import type { EventBus, EventConsumer, Unsubscribe } from "@deepractice-ai/agentx-event";
import type {
  // Stream Events (input)
  MessageStartEvent,
  MessageStopEvent,
  TextContentBlockStartEvent,
  TextContentBlockStopEvent,
  ToolUseContentBlockStartEvent,
  ToolUseContentBlockStopEvent,
  // State Events (output)
  AgentInitializingStateEvent,
  AgentReadyStateEvent,
  ConversationThinkingStateEvent,
  ConversationRespondingStateEvent,
  ToolPlannedStateEvent,
  ToolExecutingStateEvent,
  ToolCompletedStateEvent,
  StreamStartStateEvent,
  StreamCompleteStateEvent,
} from "@deepractice-ai/agentx-event";

/**
 * Agent state types
 */
type AgentState =
  | "initializing"
  | "ready"
  | "conversation_active"
  | "thinking"
  | "responding"
  | "tool_executing"
  | "idle";

/**
 * AgentStateMachine
 *
 * Automatically generates State Layer events from Stream Layer events.
 */
export class AgentStateMachine {
  private agentId: string;
  private eventBus: EventBus;
  private consumer: EventConsumer;
  private unsubscribers: Unsubscribe[] = [];

  // State tracking
  private currentState: AgentState = "initializing";

  // Conversation tracking
  private conversationStartTime: number | null = null;

  constructor(agentId: string, eventBus: EventBus) {
    this.agentId = agentId;
    this.eventBus = eventBus;
    this.consumer = eventBus.createConsumer();

    this.subscribeToStreamEvents();
  }

  /**
   * Subscribe to Stream Layer events
   */
  private subscribeToStreamEvents(): void {
    // Message lifecycle
    this.unsubscribers.push(
      this.consumer.consumeByType("message_start", (event: MessageStartEvent) => {
        this.onMessageStart(event);
      })
    );

    this.unsubscribers.push(
      this.consumer.consumeByType("message_stop", (event: MessageStopEvent) => {
        this.onMessageStop(event);
      })
    );

    // Content blocks
    this.unsubscribers.push(
      this.consumer.consumeByType(
        "text_content_block_start",
        (event: TextContentBlockStartEvent) => {
          this.onTextContentBlockStart(event);
        }
      )
    );

    this.unsubscribers.push(
      this.consumer.consumeByType(
        "text_content_block_stop",
        (event: TextContentBlockStopEvent) => {
          this.onTextContentBlockStop(event);
        }
      )
    );

    this.unsubscribers.push(
      this.consumer.consumeByType(
        "tool_use_content_block_start",
        (event: ToolUseContentBlockStartEvent) => {
          this.onToolUseContentBlockStart(event);
        }
      )
    );

    this.unsubscribers.push(
      this.consumer.consumeByType(
        "tool_use_content_block_stop",
        (event: ToolUseContentBlockStopEvent) => {
          this.onToolUseContentBlockStop(event);
        }
      )
    );
  }

  /**
   * Handle MessageStartEvent
   * Triggers: StreamStartStateEvent
   *
   * Note: ConversationStartStateEvent requires UserMessage which we don't have here.
   * It should be emitted by MessageAssembler or ExchangeTracker.
   */
  private onMessageStart(event: MessageStartEvent): void {
    this.conversationStartTime = event.timestamp;

    // Emit StreamStartStateEvent
    const streamStartEvent: StreamStartStateEvent = {
      type: "stream_start",
      uuid: this.generateId(),
      agentId: this.agentId,
      timestamp: Date.now(),
      previousState: this.currentState,
      transition: {
        reason: "message_started",
        trigger: "message_start",
      },
      data: {},
    };
    this.emitStateEvent(streamStartEvent);

    // Transition state
    this.transitionState("conversation_active");
  }

  /**
   * Handle MessageStopEvent
   * Triggers: StreamCompleteStateEvent
   *
   * Note: ConversationEndStateEvent is generated by MessageAssembler
   * because it needs AssistantMessage which we don't have here
   */
  private onMessageStop(event: MessageStopEvent): void {
    const duration = this.conversationStartTime
      ? event.timestamp - this.conversationStartTime
      : 0;

    // Emit StreamCompleteStateEvent
    const streamCompleteEvent: StreamCompleteStateEvent = {
      type: "stream_complete",
      uuid: this.generateId(),
      agentId: this.agentId,
      timestamp: Date.now(),
      previousState: this.currentState,
      transition: {
        reason: "stream_completed",
        durationMs: duration,
        trigger: "message_stop",
      },
      data: {},
    };
    this.emitStateEvent(streamCompleteEvent);

    // Transition state
    this.transitionState("idle");
    this.conversationStartTime = null;
  }

  /**
   * Handle TextContentBlockStartEvent
   * Triggers: ConversationRespondingStateEvent
   */
  private onTextContentBlockStart(_event: TextContentBlockStartEvent): void {
    const respondingEvent: ConversationRespondingStateEvent = {
      type: "conversation_responding",
      uuid: this.generateId(),
      agentId: this.agentId,
      timestamp: Date.now(),
      previousState: this.currentState,
      transition: {
        reason: "assistant_responding",
        trigger: "text_content_block_start",
      },
      data: {},
    };
    this.emitStateEvent(respondingEvent);

    this.transitionState("responding");
  }

  /**
   * Handle TextContentBlockStopEvent
   */
  private onTextContentBlockStop(_event: TextContentBlockStopEvent): void {
    // No state transition needed
  }

  /**
   * Handle ToolUseContentBlockStartEvent
   * Triggers: ToolPlannedStateEvent, ToolExecutingStateEvent
   */
  private onToolUseContentBlockStart(event: ToolUseContentBlockStartEvent): void {

    // Emit ToolPlannedStateEvent
    const toolPlannedEvent: ToolPlannedStateEvent = {
      type: "tool_planned",
      uuid: this.generateId(),
      agentId: this.agentId,
      timestamp: Date.now(),
      data: {
        id: event.data.id,
        name: event.data.name,
        // Input will be accumulated from InputJsonDeltaEvent
        input: {},
      },
    };
    this.emitStateEvent(toolPlannedEvent);

    // Emit ToolExecutingStateEvent
    const toolExecutingEvent: ToolExecutingStateEvent = {
      type: "tool_executing",
      uuid: this.generateId(),
      agentId: this.agentId,
      timestamp: Date.now(),
      previousState: this.currentState,
      transition: {
        reason: "tool_execution_started",
        trigger: "tool_use_content_block_start",
      },
      data: {},
    };
    this.emitStateEvent(toolExecutingEvent);

    this.transitionState("tool_executing");
  }

  /**
   * Handle ToolUseContentBlockStopEvent
   * Triggers: ToolCompletedStateEvent
   *
   * Note: We don't have the actual tool result here, it comes from external execution.
   * This event just marks that the tool invocation block in the stream has ended.
   * Actual ToolCompletedStateEvent with results should be emitted when tool execution finishes.
   */
  private onToolUseContentBlockStop(_event: ToolUseContentBlockStopEvent): void {
    // Don't emit ToolCompletedStateEvent here because we don't have the result yet.
    // The actual tool execution happens outside the stream.
    // ToolCompletedStateEvent should be emitted by the tool execution layer.

    this.transitionState("conversation_active");
  }

  /**
   * Transition to new state
   */
  private transitionState(newState: AgentState): void {
    this.currentState = newState;
  }

  /**
   * Emit State event to EventBus
   */
  private emitStateEvent(
    event:
      | AgentInitializingStateEvent
      | AgentReadyStateEvent
      | ConversationThinkingStateEvent
      | ConversationRespondingStateEvent
      | ToolPlannedStateEvent
      | ToolExecutingStateEvent
      | ToolCompletedStateEvent
      | StreamStartStateEvent
      | StreamCompleteStateEvent
  ): void {
    const producer = this.eventBus.createProducer();
    producer.produce(event as any);
  }

  /**
   * Destroy state machine and unsubscribe
   */
  destroy(): void {
    this.unsubscribers.forEach((unsub) => unsub());
    this.unsubscribers = [];
  }

  private generateId(): string {
    return `state_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
  }
}
