# @deepractice-ai/agentx-types

> Core type definitions for the Deepractice AgentX ecosystem

## Overview

`agentx-types` is a **pure TypeScript type library** that defines the domain models for building AI agents. It provides the foundational data structures for messages, LLM interactions, sessions, and Model Context Protocol (MCP) integration.

**Key Characteristics:**
- **Zero runtime dependencies** - Pure TypeScript types
- **Platform-agnostic** - Works in Node.js, Browser, and Edge runtimes
- **Contract-first design** - Single source of truth for data structures
- **Type-safe** - Discriminated unions with type guards
- **Well-documented** - Every type includes JSDoc comments

## Installation

```bash
npm install @deepractice-ai/agentx-types
# or
pnpm add @deepractice-ai/agentx-types
# or
yarn add @deepractice-ai/agentx-types
```

## Domain Architecture

The library is organized into 6 major domains:

```
agentx-types/
├── message/          # Conversation messages and content
├── llm/              # LLM provider abstractions
├── session/          # Conversation sessions
├── agent/            # Agent metadata
├── mcp/              # Model Context Protocol types
└── guards/           # TypeScript type guards
```

---

## 1. Message Domain

### Message Types

The `Message` type is a **discriminated union** based on the `role` field:

```typescript
import { Message, UserMessage, AssistantMessage } from '@deepractice-ai/agentx-types';

type Message =
  | UserMessage         // role: "user"
  | AssistantMessage    // role: "assistant"
  | SystemMessage       // role: "system"
  | ToolUseMessage      // role: "tool-use"
  | ErrorMessage;       // role: "error"
```

#### UserMessage

Messages sent by the user. Supports text, images, and files.

```typescript
interface UserMessage {
  id: string;
  role: "user";
  content: string | Array<TextPart | ImagePart | FilePart>;
  timestamp: number;
  parentId?: string;  // For message threading
}
```

**Example:**
```typescript
const textMessage: UserMessage = {
  id: "msg-001",
  role: "user",
  content: "Hello, how are you?",
  timestamp: Date.now(),
};

const multiModalMessage: UserMessage = {
  id: "msg-002",
  role: "user",
  content: [
    { type: "text", text: "What's in this image?" },
    { type: "image", data: "base64...", mediaType: "image/png" },
  ],
  timestamp: Date.now(),
};
```

#### AssistantMessage

Messages generated by the AI assistant. Can include thinking process, tool calls, and rich content.

```typescript
interface AssistantMessage {
  id: string;
  role: "assistant";
  content: string | Array<TextPart | ThinkingPart | ToolCallPart | FilePart>;
  timestamp: number;
  parentId?: string;
  usage?: TokenUsage;  // Token consumption stats
}
```

**Example:**
```typescript
const response: AssistantMessage = {
  id: "msg-003",
  role: "assistant",
  content: "I'm doing well, thank you!",
  timestamp: Date.now(),
  usage: {
    input: 10,
    output: 8,
  },
};

const responseWithThinking: AssistantMessage = {
  id: "msg-004",
  role: "assistant",
  content: [
    { type: "thinking", reasoning: "Let me analyze this image..." },
    { type: "text", text: "I see a cat in the image." },
  ],
  timestamp: Date.now(),
};
```

#### SystemMessage

System notifications and status updates.

```typescript
interface SystemMessage {
  id: string;
  role: "system";
  content: string;  // Always plain text
  timestamp: number;
  parentId?: string;
}
```

#### ToolUseMessage

Complete record of tool usage (call + result).

```typescript
interface ToolUseMessage {
  id: string;
  role: "tool-use";
  toolCall: ToolCallPart;     // Tool invocation
  toolResult: ToolResultPart;  // Execution result
  timestamp: number;
  parentId?: string;
}
```

**Example:**
```typescript
const toolUse: ToolUseMessage = {
  id: "msg-005",
  role: "tool-use",
  toolCall: {
    type: "tool-call",
    id: "call-001",
    name: "get_weather",
    input: { city: "San Francisco" },
  },
  toolResult: {
    type: "tool-result",
    id: "call-001",
    name: "get_weather",
    output: {
      type: "json",
      value: { temperature: 72, condition: "sunny" },
    },
  },
  timestamp: Date.now(),
};
```

#### ErrorMessage

Structured error information displayed in conversation history.

```typescript
type ErrorSubtype = "system" | "agent" | "llm" | "validation" | "unknown";
type ErrorSeverity = "fatal" | "error" | "warning";

interface ErrorMessage {
  id: string;
  role: "error";
  subtype: ErrorSubtype;
  severity: ErrorSeverity;
  message: string;
  code?: string;
  details?: unknown;
  recoverable?: boolean;
  stack?: string;
  timestamp: number;
}
```

**Example:**
```typescript
const error: ErrorMessage = {
  id: "msg-006",
  role: "error",
  subtype: "llm",
  severity: "error",
  message: "Rate limit exceeded",
  code: "RATE_LIMIT_ERROR",
  recoverable: true,
  timestamp: Date.now(),
};
```

### Content Parts

Messages can contain rich, multi-modal content through **ContentPart** types:

```typescript
type ContentPart =
  | TextPart          // Plain text
  | ThinkingPart      // AI reasoning
  | ImagePart         // Images
  | FilePart          // File attachments
  | ToolCallPart      // Tool invocations
  | ToolResultPart;   // Tool results
```

#### TextPart

```typescript
interface TextPart {
  type: "text";
  text: string;  // Supports Markdown
}
```

#### ThinkingPart

AI's reasoning process (extended thinking).

```typescript
interface ThinkingPart {
  type: "thinking";
  reasoning: string;
  tokenCount?: number;
}
```

#### ImagePart

```typescript
interface ImagePart {
  type: "image";
  data: string;  // Base64-encoded or URL
  mediaType: "image/png" | "image/jpeg" | "image/gif" | "image/webp";
  name?: string;
}
```

#### FilePart

```typescript
interface FilePart {
  type: "file";
  data: string;      // Base64-encoded or URL
  mediaType: string; // IANA media type
  filename?: string;
}
```

#### ToolCallPart

AI's request to invoke a tool.

```typescript
interface ToolCallPart {
  type: "tool-call";
  id: string;
  name: string;
  input: Record<string, unknown>;
}
```

#### ToolResultPart

Result of tool execution.

```typescript
interface ToolResultPart {
  type: "tool-result";
  id: string;
  name: string;
  output: ToolResultOutput;
}

type ToolResultOutput =
  | { type: "text"; value: string }
  | { type: "json"; value: unknown }
  | { type: "error-text"; value: string }
  | { type: "error-json"; value: unknown }
  | { type: "execution-denied"; reason?: string }
  | { type: "content"; value: Array<TextPart | ImagePart | FilePart> };
```

---

## 2. LLM Domain

### LLMProvider

Defines the capabilities of a language model provider.

```typescript
interface LLMProvider {
  provider: string;          // e.g., "anthropic", "openai"
  modelId: string;           // e.g., "claude-3-5-sonnet-20241022"
  supportsStreaming: boolean;
  supportsTools: boolean;
  supportsVision: boolean;
  supportsCaching: boolean;
  supportsThinking?: boolean;
}
```

### LLMConfig

Inference configuration parameters.

```typescript
interface LLMConfig {
  model: string;
  temperature?: number;         // 0-2
  maxTokens?: number;
  topP?: number;                // 0-1
  topK?: number;
  presencePenalty?: number;     // -2.0 to 2.0
  frequencyPenalty?: number;    // -2.0 to 2.0
  stopSequences?: string[];
  maxThinkingTokens?: number;   // For extended thinking
}
```

### LLMRequest

Complete request for a single LLM inference call.

```typescript
interface LLMRequest {
  messages: Message[];
  config: LLMConfig;
  systemPrompt?: string;
}
```

### LLMResponse

Complete response from LLM inference.

```typescript
type StopReason = "end_turn" | "max_tokens" | "tool_use" | "content_filter" | "error" | "other";

interface LLMResponse {
  content: string | ContentPart[];
  stopReason: StopReason;
  usage: TokenUsage;
  finishTime: Date;
  model?: string;
}
```

### StreamChunk

Incremental output during streaming generation.

```typescript
interface TextChunk {
  type: "text";
  delta: string;   // Incremental text
  index: number;
}

interface ThinkingChunk {
  type: "thinking";
  delta: string;   // Incremental reasoning
  index: number;
}

interface ToolUseChunk {
  type: "tool-use";
  name: string;
  id: string;
  inputDelta?: string;  // Partial JSON
}

type StreamChunk = TextChunk | ThinkingChunk | ToolUseChunk;
```

### TokenUsage

Token consumption tracking.

```typescript
interface TokenUsage {
  input: number;
  output: number;
  cacheRead?: number;   // Tokens read from cache
  cacheWrite?: number;  // Tokens written to cache
}
```

---

## 3. Session Domain

### Session

A conversation container that holds multiple messages.

```typescript
interface Session {
  id: string;
  title: string;
  messages: Message[];
  createdAt: Date;
  updatedAt: Date;
  metadata?: Record<string, unknown>;  // Extension point
}
```

**Example:**
```typescript
const session: Session = {
  id: "session-001",
  title: "Code Review Discussion",
  messages: [
    { id: "msg-001", role: "user", content: "Review my code", timestamp: Date.now() },
    { id: "msg-002", role: "assistant", content: "Let me analyze...", timestamp: Date.now() },
  ],
  createdAt: new Date("2025-01-01"),
  updatedAt: new Date("2025-01-01"),
  metadata: {
    tags: ["coding", "review"],
    userId: "user-123",
  },
};
```

---

## 4. Agent Domain

### AgentMetadata

Metadata about an agent instance.

```typescript
interface AgentMetadata {
  id: string;
  name: string;
  description?: string;
  createdAt: number;
  version?: string;
  tags?: string[];
  [key: string]: unknown;  // Extension point
}
```

**Example:**
```typescript
const agentMeta: AgentMetadata = {
  id: "agent-001",
  name: "Code Review Assistant",
  description: "Helps review code and suggest improvements",
  createdAt: Date.now(),
  version: "1.0.0",
  tags: ["coding", "review", "debugging"],
  customField: "custom value",
};
```

---

## 5. MCP (Model Context Protocol) Domain

### MCP Protocol

```typescript
const LATEST_PROTOCOL_VERSION = "2025-06-18";
const SUPPORTED_PROTOCOL_VERSIONS = ["2025-06-18", "2025-03-26", "2024-11-05"];

type McpProtocolVersion = "2025-06-18" | "2025-03-26" | "2024-11-05";
```

### MCP Tools

Tools that can be invoked by the LLM.

```typescript
interface McpTool {
  name: string;
  description?: string;
  inputSchema: JsonSchema;  // JSON Schema for parameters
  annotations?: {
    title?: string;
    [key: string]: unknown;
  };
}

interface JsonSchema {
  type: "object";
  properties?: Record<string, JsonSchemaProperty>;
  required?: string[];
  additionalProperties?: boolean;
  description?: string;
}
```

**Example:**
```typescript
const weatherTool: McpTool = {
  name: "get_weather",
  description: "Get weather for a city",
  inputSchema: {
    type: "object",
    properties: {
      city: {
        type: "string",
        description: "City name",
      },
      units: {
        type: "string",
        enum: ["celsius", "fahrenheit"],
        default: "celsius",
      },
    },
    required: ["city"],
  },
};
```

### MCP Tool Results

```typescript
interface TextContent {
  type: "text";
  text: string;
}

interface ImageContent {
  type: "image";
  data: string;        // Base64-encoded
  mimeType: string;
}

interface ResourceContent {
  type: "resource";
  resource: {
    uri: string;
    name?: string;
    title?: string;
    mimeType?: string;
    text?: string;
    blob?: string;     // Base64-encoded binary
  };
}

interface McpToolResult {
  content: Array<TextContent | ImageContent | ResourceContent>;
  isError?: boolean;
  _meta?: Record<string, unknown>;
}
```

### MCP Resources

Static data sources that can be accessed by the LLM.

```typescript
interface McpResource {
  uri: string;
  name: string;
  title?: string;
  description?: string;
  mimeType?: string;
  size?: number;
  annotations?: Record<string, unknown>;
}

interface McpResourceTemplate {
  uriTemplate: string;  // e.g., "file:///{path}"
  name: string;
  title?: string;
  description?: string;
  mimeType?: string;
}
```

### MCP Prompts

Reusable prompt templates with parameters.

```typescript
interface McpPrompt {
  name: string;
  title?: string;
  description?: string;
  arguments?: McpPromptArgument[];
}

interface McpPromptArgument {
  name: string;
  description?: string;
  required?: boolean;
}
```

### MCP Server

```typescript
interface McpServerCapabilities {
  experimental?: Record<string, unknown>;
  logging?: Record<string, unknown>;
  prompts?: {
    listChanged?: boolean;
  };
  resources?: {
    subscribe?: boolean;
    listChanged?: boolean;
  };
  tools?: {
    listChanged?: boolean;
  };
}

interface McpServerInfo {
  name: string;
  version: string;
}

interface McpInitializeResult {
  protocolVersion: string;
  capabilities: McpServerCapabilities;
  serverInfo: McpServerInfo;
  instructions?: string;
  _meta?: Record<string, unknown>;
}
```

---

## 6. Type Guards

Type-safe runtime checks for discriminated unions.

### Message Guards

```typescript
import { isUserMessage, isAssistantMessage, isSystemMessage } from '@deepractice-ai/agentx-types';

function processMessage(message: Message) {
  if (isUserMessage(message)) {
    // TypeScript knows: message is UserMessage
    console.log("User said:", message.content);
  } else if (isAssistantMessage(message)) {
    // TypeScript knows: message is AssistantMessage
    console.log("Assistant replied:", message.content);
    if (message.usage) {
      console.log("Tokens used:", message.usage.input + message.usage.output);
    }
  } else if (isErrorMessage(message)) {
    // TypeScript knows: message is ErrorMessage
    console.error(`[${message.severity}] ${message.message}`);
  }
}
```

**Available guards:**
- `isUserMessage(message)`
- `isAssistantMessage(message)`
- `isSystemMessage(message)`
- `isToolUseMessage(message)`
- `isErrorMessage(message)`

### Content Part Guards

```typescript
import { isTextPart, isImagePart, isToolCallPart } from '@deepractice-ai/agentx-types';

function processContent(parts: ContentPart[]) {
  parts.forEach((part) => {
    if (isTextPart(part)) {
      console.log("Text:", part.text);
    } else if (isImagePart(part)) {
      console.log("Image:", part.mediaType);
    } else if (isThinkingPart(part)) {
      console.log("Thinking:", part.reasoning);
    } else if (isToolCallPart(part)) {
      console.log("Tool call:", part.name, part.input);
    }
  });
}
```

**Available guards:**
- `isTextPart(part)`
- `isThinkingPart(part)`
- `isImagePart(part)`
- `isFilePart(part)`
- `isToolCallPart(part)`
- `isToolResultPart(part)`

---

## Design Philosophy

### 1. Pure Data Structures

All types represent **data**, not behavior. No methods, no state, just data.

```typescript
// ✅ Good - Pure data
interface Message {
  id: string;
  role: string;
  content: string;
}

// ❌ Bad - Behavior mixed in
interface Message {
  id: string;
  send(): Promise<void>;  // Behavior belongs elsewhere
}
```

### 2. Discriminated Unions

Use `type` or `role` fields for type discrimination.

```typescript
type ContentPart =
  | { type: "text"; text: string }
  | { type: "image"; data: string; mediaType: string };

function render(part: ContentPart) {
  switch (part.type) {
    case "text":
      return part.text;      // TypeScript knows: part.text exists
    case "image":
      return `<img src="${part.data}" />`;  // TypeScript knows: part.data exists
  }
}
```

### 3. Platform-Agnostic

Types work everywhere - Node.js, Browser, Edge, Deno.

```typescript
// ✅ Platform-agnostic
interface Message {
  timestamp: number;  // Unix timestamp
}

// ❌ Node.js-specific
interface Message {
  timestamp: Buffer;  // Buffer only exists in Node.js
}
```

### 4. Extension Points

Use `metadata` or index signatures for extensibility.

```typescript
interface Session {
  id: string;
  title: string;
  metadata?: Record<string, unknown>;  // Extension point
}

const session: Session = {
  id: "session-001",
  title: "My Session",
  metadata: {
    customField: "custom value",  // ✅ Extensible
  },
};
```

---

## Common Patterns

### Pattern 1: Creating Messages

```typescript
import { UserMessage, AssistantMessage } from '@deepractice-ai/agentx-types';

function createUserMessage(text: string): UserMessage {
  return {
    id: crypto.randomUUID(),
    role: "user",
    content: text,
    timestamp: Date.now(),
  };
}

function createAssistantMessage(text: string, usage?: TokenUsage): AssistantMessage {
  return {
    id: crypto.randomUUID(),
    role: "assistant",
    content: text,
    timestamp: Date.now(),
    usage,
  };
}
```

### Pattern 2: Multi-Modal Content

```typescript
const userMessage: UserMessage = {
  id: crypto.randomUUID(),
  role: "user",
  content: [
    { type: "text", text: "Analyze this image:" },
    {
      type: "image",
      data: "data:image/png;base64,iVBORw0KGgoAAAANS...",
      mediaType: "image/png",
    },
  ],
  timestamp: Date.now(),
};
```

### Pattern 3: Tool Usage Tracking

```typescript
const toolUse: ToolUseMessage = {
  id: crypto.randomUUID(),
  role: "tool-use",
  toolCall: {
    type: "tool-call",
    id: "call-001",
    name: "search_web",
    input: { query: "TypeScript best practices" },
  },
  toolResult: {
    type: "tool-result",
    id: "call-001",
    name: "search_web",
    output: {
      type: "json",
      value: {
        results: [
          { title: "TypeScript Handbook", url: "https://..." },
        ],
      },
    },
  },
  timestamp: Date.now(),
};
```

### Pattern 4: Error Handling

```typescript
const errorMessage: ErrorMessage = {
  id: crypto.randomUUID(),
  role: "error",
  subtype: "llm",
  severity: "error",
  message: "Rate limit exceeded. Please try again in 60 seconds.",
  code: "RATE_LIMIT_ERROR",
  recoverable: true,
  timestamp: Date.now(),
};
```

---

## Integration with Other Packages

`agentx-types` is the foundation for the entire AgentX ecosystem:

```
agentx-ui ──────→ agentx-browser ──→ agentx-core ──→ agentx-types
                                           ↘
                                             agentx-api
                                           ↗
agentx-node ────────────────────→ agentx-core
```

**Usage examples:**

```typescript
// In agentx-core
import { Message, Session, LLMRequest } from '@deepractice-ai/agentx-types';

class Agent {
  async chat(request: LLMRequest): Promise<Message> {
    // Implementation
  }
}

// In agentx-node
import { LLMProvider, LLMResponse } from '@deepractice-ai/agentx-types';

class ClaudeProvider implements LLMProvider {
  provider = "anthropic";
  modelId = "claude-3-5-sonnet-20241022";
  // ...
}

// In agentx-ui
import { Message, isUserMessage, isAssistantMessage } from '@deepractice-ai/agentx-types';

function ChatMessage({ message }: { message: Message }) {
  if (isUserMessage(message)) {
    return <UserBubble>{message.content}</UserBubble>;
  }
  // ...
}
```

---

## Contributing

This package follows **strict type-only conventions**:

1. **No runtime code** - Only TypeScript types and interfaces
2. **No dependencies** - Keep the package pure
3. **One file, one primary type** - Use PascalCase filenames
4. **Discriminated unions** - Always use `type` or `role` for discrimination
5. **JSDoc comments** - Document every public type

---

## License

MIT © Deepractice AI
